# 经典排序算法

### 1.冒泡排序
	时间复杂度：O(n^2)
	
	空间复杂度：O(1)
	
	稳定排序
######[源代码]()

### 2.插入排序
	时间复杂度：O(n^2)
	
	空间复杂度：O(1)
	
	稳定排序
######[源代码]()

### 3.选择排序
	时间复杂度：O(n^2)
	
	空间复杂度：O(1)
	
	不稳定排序
######[源代码]()

### 4.快速排序
	时间复杂度：平均-O(n*log(n)) 最坏-O(n^2)
	
	空间复杂度：O(1)
	
	不稳定排序
######[源代码]()

### 5.归并排序
	时间复杂度：O(n*log(n))
	
	空间复杂度：O(n)
	
	不稳定排序
######[源代码]()

### 6.堆排序
	时间复杂度：O(n*log(n))
	
	空间复杂度：O(1)
	
	不稳定排序
######[源代码]()

### 7.希尔排序
	时间复杂度：与选择步长序列有关，最优的O(n*log(n))
	
	空间复杂度：O(1)
	
	不稳定排序
######[源代码]()

### 8.基数排序
	时间复杂度：O(n)
	
	空间复杂度：O(n+k)
	
	稳定排序
######[源代码]()

### 9.计数排序
	时间复杂度：O(n+k)
	
	空间复杂度：O(n+k)
	
	稳定排序
######[源代码]()

### 10.桶排序
	时间复杂度：O(n)
	
	空间复杂度：O(2n)
	
	稳定排序
######[源代码]()

### 相关定义
**稳定排序**

所有相等的数经过某种排序方法后，仍能保持它们在排序之前的相对次序

**非稳定排序**

所有相等的数经过某种排序方法后，不能保持它们在排序之前的相对次序

**内部排序**

如果在排序过程中，所有需要排序的数都能够放进内存中，直接在内存中调整它们的存储顺序

**外部排序**

如果在排序过程中，需要排序的数据量过于庞大，不能一次存储进内存中，只有一部分一部分数据调入内存，进行排序，并借助内存调整数在外存中的存放顺序排序
