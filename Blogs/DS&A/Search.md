# 搜索基础

#### 顺序查找

	最简单常用的查找算法，顺序遍历序列即可，找到返回第一次找到的位置，查找失败，返回-1，
	应用非常广泛。
	优化：添加哨兵，减少比较次数
	
	时间复杂度：O(n)

#### 二分查找

	只能用于有序序列，每次比较序列区间的中值，小于中值则查找左边，大于中值则查找右边，
	折半查找序列，成功返回第一次找到元素的位置，不成功返回该元素插入序列的位置(也可以-1)。
	
	时间复杂度：O(logn)

#### 散列化
	
	利用hash函数处理序列，可以实现直接映射查找，速度非常快，但是浪费时间
	
	时间复杂度：O(1)，空间复杂度：O(k)

#### 二分查找树

	logn的平均效率实现查找，插入。

#### 关键字索引

	索引是优化查找最有效的方法，特别适合于大型数据库。
	跳表的实现。

## 树搜索
#### 先序遍历
先访问树的跟节点，然后依次遍历其左子树，右子树

#### 中序遍历
先访问左子树，中间访问根节点，再访问右子树

#### 后序遍历
先访问左子树，再访问右子树，最后访问根节点

## 图搜索
#### 广度优先搜索
定义

	一种在树（或图）中进行搜索的算法，从根结点开始，优先按照树的层次进行搜索，搜索同一层中的各结点，
	通常从左往右进行进行搜索时，同时追踪当前层中结点的子结点，当前一层搜索完毕后，转入遍历下一层中
	最左边的结点，最下层最右端是最末结点（即该结点深度最大，且在当前层次的最右端）

要点

	当树的宽度大于深度时，该搜索算法较优，进行树的遍历时，使用队列存储树的信息
	原因是：使用队列比深度优先搜索更为内存密集，由于需要存储指针，队列需要占用更多内存

	时间复杂度：O(|E| + |V|)
		E 是边的数目
		V 是顶点的数目
		
#### 深度优先搜索
定义

	一种在树（或图）中进行搜索的算法，从根结点开始，优先按照树的深度进行搜索，从左边开始一直往下遍历
	树的结点，直到不能继续这一操作，一旦到达某一分支的最末端，将返回上一结点并遍历该分支的右子结点，
	如果可以将从左往右遍历子结点，当前这一分支搜索完毕后，转入根节点的右子结点，然后不断遍历左子节点，
	直到到达最底端，最右的结点是最末结点

要点

	当树的深度大于宽度时，该搜索算法较优，利用堆栈将结点压栈
	堆栈是“后进先出”的数据结构，所以无需跟踪结点的指针。与广度优先搜索相比，它对内存的要求不高。
	一旦不能向左继续遍历，则对栈进行操作

	时间复杂度：O(|E| + |V|)
		E 是边的数目
		V 是结点的数目

广度优先搜索 VS. 深度优先搜索

	选取何种算法取决于树的大小和形态
	就宽度而言，较浅的树适用广度优先搜索
	就深度而言，较窄的树适用深度优先搜索

由于广度优先搜索（BFS）使用队列来存储结点的信息和它的子结点，所以需要用到的内存可能超过当前计算机可提供的内存，
如果要在某一深度很大的树中使用深度优先搜索（DFS），其实在搜索中大可不必走完全部深度。
广度优先搜索趋于一种循环算法，深度优先搜索趋于一种递归算法
