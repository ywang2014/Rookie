# 经典排序算法

### 1.冒泡排序
	时间复杂度：O(n^2)		空间复杂度：O(1)		稳定排序
	
	基本思想：两两比较相邻记录的关键字，逆序则交换。
	
	优化：
		1.设置标记位，如果序列提前完成排序，则函数直接返回。
		2.记录本轮中未排序的终点，下次遍历直接做这中间的排序即可。
		
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/bubbleSort)

### 2.插入排序
	时间复杂度：O(n^2)		空间复杂度：O(1)		稳定排序
	
	基本思想：将一个元素，插入到已排序好的列表中，得到一个新的有序表，一直插入n个元素，则完成排序。
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/insertSort)

### 3.选择排序
	时间复杂度：O(n^2) 		空间复杂度：O(1)	不稳定排序
	
	基本思想：每次选择序列中最小的元素，添加到有序数列的末尾即可，直到全部有序。
		找到序列中的最小元素位置，将当前位置元素与最小元素互换(因此不稳定)
	
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/selectSort)

### 4.快速排序
	时间复杂度：平均-O(n*log(n)) 最坏-O(n^2)		空间复杂度：O(nlogn)(递归深度)		不稳定排序
	
	基本思想：选择一个轴点，通过一次遍历，将数列分成两个部分，小于轴点的元素放在左边，大于轴点的数放在右边。
	然后通过递归的方法，分别处理左边和右边部分，直到划分为1个元素时，退出递归，即排序完成。
	
	优化：
		1.三点取中法，解决快排对于有序数列的退化情况
		2.借用随机数生成器，选择轴点，也可以处理有序数列的退化情况
		3.对于很多相等数字情况，分三部分，小于轴点，等于轴点，大于轴点
		4.元素少于10个的时候，使用插入排序，代替快速排序
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/quickSort)

### 5.归并排序
	时间复杂度：O(n*log(n))		空间复杂度：O(n+log(n))		稳定排序
	
	基本思想：将含有n个元素的序列看做n个含有一个元素的序列，两两归并，一直递归到最后。
	与快速排序过程相反(自底向上 <--> 自顶向下)
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/mergeSort)

### 6.堆排序
	时间复杂度：O(n*log(n))		空间复杂度：O(1)		不稳定排序
		
	基本思想：利用堆结构，进行排序。
	第一步，将序列构造成一个大根堆，则序列的最大值即为堆的跟节点值，将堆顶元素与最后元素交换(即删除)，构造剩下的n-1个节点的堆，
	最终剩下一个节点时，则排序完成。
		
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/heapSort)

### 7.希尔排序
	时间复杂度：与选择步长序列有关，最优的O(n*log(n))，平均O(n^1.5)		空间复杂度：O(1)		不稳定排序
	
	基本思想：将序列数组分割为若干个小的子序列，对子序列进行插入排序；根据增量序列，逐步缩小增量序列，继续插入排序，
	直到增量序列大小为1，完成最后一次插入排序，即整个序列完成排序。
	特殊的插入排序
	
	优化：使用不同的增量序列：
		N/2, N/4, ... 2, 1
		2^k-1, ... 7, 3, 1 
		1, 2, 3, 5, 8 ... (fibonacci)
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/shellSort)

### 8.基数排序
	时间复杂度：O(n)		空间复杂度：O(n+k)		稳定排序
	
	基本思想：非比较型，整数排序算法，原理就是将整数按位数切割成不同的数字，然后按位数比较，依次进行一次排序，
	从最低位到最高位排序一遍后，即可完成序列排序。
	
	基数排序的思想，可以扩展为特定格式的浮点数，字符串等的排序方法。
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/radixSort)

### 9.计数排序
	时间复杂度：O(n+k)		空间复杂度：O(n+k)		稳定排序
	
	基本思想：计数排序依赖一个排序数组，假设其元素值范围在 0-K之间，遍历一次待排序数组，统计各元素出现的频率，
	按照频率修改其待排序数组，即完成排序工作。
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/countSort)

### 10.桶排序
	时间复杂度：O(n)	空间复杂度：O()		排序
	
	基本思想：将数组分割成有限数量的桶，对每个桶单独排序，在对非空的桶进行插入排序，然后还原待排序数列，
	即完成排序工作。
	适用于位数相同，均匀分布的数列
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/bucketSort)

### 11.地精排序
	时间复杂度：O(n^2)	空间复杂度：O(1)		稳定排序
	
	基本思想：号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到
	把这个数字放好为止。
	遍历完数组，则排序完成。
	
[源代码](https://github.com/ywang2014/Rookie/tree/master/Src/sort/gnomeSort)

####其他排序算法
1.鸽巢排序(pigeonhole sort)
	
	原理类似桶排序,同样需要一个很大的鸽巢[桶排序里管这个叫桶]
	鸽巢其实就是数组,数组的索引位置就表示值,该索引位置的值表示出现次数,如果全部为1次或0次那就是桶排序
	就是计数排序

2.鸡尾酒排序(cocktail sort)
	
	鸡尾酒排序基于冒泡排序,双向循环。鸡尾酒一次到头后就回返回来,再到头后再过去,来回比
	第一趟过去，依次比较交换，第一趟回来时，也是依次比较交换，一个来回能排两个数字

3.奇偶排序(odd-even sort)
	
	比较性质的排序,基本思路是奇数列排一趟序,偶数列排一趟序,再奇数排,再偶数排,直到全部有序

4.梳排序(comb sort)
	
	梳排序还是基于冒泡排序,与冒泡不同的是,梳排序比较的是固定距离处的数的比较和交换,类似希尔那样
	这个固定距离是待排数组长度除以1.3得到近似值,下次则以上次得到的近似值再除以1.3,直到距离小至3时,以1递减
	特殊步长的希尔排序

5.耐心排序(patience sort)

	排序的关键在建桶和入桶规则上
	建桶规则:如果没有桶,新建一个桶;如果不符合入桶规则那么新建一个桶
	入桶规则:只要比桶里最上边的数字小即可入桶,如果有多个桶可入,那么按照从左到右的顺序入桶即可
	
	例子：
		举个例子,待排数组[6 4 5 1 8 7 2 3]
		第一步,取数字6出来,此时一个桶没有,根据建桶规则1新建桶,将把自己放进去,为了表述方便该桶命名为桶1或者1号桶
		第二步,取数字4出来,由于4符合桶1的入桶规则,所以入桶1,并放置在6上边,如下图2所示
		第三步,取数字5出来,由于5不符合桶1的入桶规则,比桶1里最上边的数字大,此时又没有其它桶,那么根据建桶规则新建桶2,放入住该桶
		第四步,取数字1出来,1即符合入1号桶的规则,比4小嘛,也符合入2号桶的规则,比5也小,两个都可以入,根据入桶规则1入住1号桶(实际入住2号桶也没关系)
		第五步,取数字8出来,8比1号桶的掌门1大,比2号桶的掌门5也大,而且就这俩桶,所以8决定自立门派,建立了3号桶,并入住该桶成为首位掌门
		第六步,取数字7出来,1号桶,2号桶的掌门都不行,最后被3号桶收服,投奔了3号桶的门下
		第七步,取数字2出来,被2号桶掌门收了
		第八步,取数字3出来,被3号桶的现任掌门7收了
		全部入桶完毕....

6.珠排序(bead sort)

	一个数字3用3个1来表示，一个数字9用9个1来表示,珠排序中的珠指的是每一个1,它把每一个1想像成一个珠子,
	这些珠子被串在一起,想像下算盘。
	
	排序原理：有两个数字,4和3,分别串在四条线上,于是数字4的最后一个珠子下落,因为它下边是空的,自由下落
		n表示待排序数组的长度,有多少数字就有多少层,横向表示一层
		m表示有多少个珠子,就是多少个1,这取决于最大数是多少
		算盘竖起来，珠子全部做自由落体运动，自由下落，稳定后，即排好序。

7.Proxmap Sort
	
	排序是桶排序和基数排序的改进
	与桶的区别在于入桶规则,桶排序里是1入1号桶,2入2号桶，这个排序把数字分区了,然后给出一个所谓的键。 
	例如它规定0-9都入0号桶，10-19入2号桶

8.Flash Sort
	
	FlashSort依然类似桶排序,改进了对要使用的桶的预测,或者说,减少了无用桶的数量从而节省了空间。
	例如：待排数字[ 6 2 4 1 5 9 100 ]	桶排需要100个桶,而flash sort则由于可以预测桶则只需要7个桶，
	即待排数组长度个桶。
	
	如何预测将要使用的桶号，有这么一个公式：K(ai) = 1 + INT{(m-1)[(ai-amin)/(amax-amin)]}
	前置条件：数组最大值，最小值，数组长度
	
	如果某一个桶中有多个元素，则使用其他排序方法即可。(此桶数字肯定很小)

9.Strand Sort
	
	首先需要一个空的数组用来存放最终的输出结果
	然后每次遍历待排数组,得到一个"子有序数组",然后将"子有序数组"与"有序数组"合并排序
	重复上述操作直到待排数组为空结束

10.Cycle Sort

	Cycle sort的思想与计数排序相似
	圈排序与计数排序的区别在于圈排序只给那些需要计数的数字计数
	
	圈排序，根据排完序之后数组索引，进行交换。首先确定第一个元素，最终的位置，而该位置旧的元素，最终应该在的位置，。。。
	遍历一次数组，找到所有相关联的元素。一圈又一圈。
	如果某一圈，只有一个元素，说明该元素不需要交换，即其位置就是最终位置。
	
	实现：如何知道排完序后数组的索引呢？
	例如：6 2 4 1 5 9
		1.将6取出来,计算出有4个数字比6小,将6放入索引4,同时原索引4位置的数字5出列
		2.当前数字5,计算出有3个数字比5小,将5放入索引3,同时原索引3位置的数字1出列
		3.当前数字1,计算出有0个数字比1小,将1放入索引0,索引0处为空,这圈完毕
		4.取出下一个数字2,计算出有1个数字比2小,将2放入索引1处,发现它本来就在索引1处
	
11.Library Sort 
	
	排列图书时,如果在每本书之间留一定的空隙,那么在进行插入时就有可能会少移动一些书,说白了就是在插入排序的基础上,
	给书与书之间留一定的空隙,这个空隙越大,需要移动的书就越少,这是它的思路,用空间换时间
	图书馆排序的关键是分配空间,分配完空间后直接使用插入排序即可
	
	例如：[ 6 2 4 1 5 9 ]
	排序：[ 0 0 6 0 0 2 0 0 4 0 0 1 0 0 5 0 0 9 ]

[资源出处](http://blog.sina.com.cn/s/blog_7f5ad8c20101bc10.html)

推荐学习：

	《视频：6 分钟演示 15 种排序算法》
	《视觉直观感受 7 种常用的排序算法》
	《匈牙利 Sapientia 大学的 6 种排序算法舞蹈视频》
	《SORTING：可视化展示排序算法的原理，支持单步查看》
	《VisuAlgo：通过动画学习算法和数据结构》

#### 相关定义
**稳定排序**

所有相等的数经过某种排序方法后，仍能保持它们在排序之前的相对次序

**非稳定排序**

所有相等的数经过某种排序方法后，不能保持它们在排序之前的相对次序

**内部排序**

如果在排序过程中，所有需要排序的数都能够放进内存中，直接在内存中调整它们的存储顺序

**外部排序**

如果在排序过程中，需要排序的数据量过于庞大，不能一次存储进内存中，只有一部分一部分数据调入内存，进行排序，并借助内存调整数在外存中的存放顺序排序

**inline**

内敛函数(在线函数)：直接展开，效率更高，但是大型程序中，多个包含头文件时，存在重复定义等问题	C语言的 宏
