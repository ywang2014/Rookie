# 算法类型基础

#### 递归算法
定义

	在定义过程中调用其本身的算法
	递归事件：用于触发递归的条件语句，驱动事件
	基本事件：用于结束递归的条件语句
	
要点

	栈级过深和栈溢出：需要估测递归深度，考虑空间复杂度
	**不论基本事件是否被触发，它在递归中都不可或缺**
	递归常用于图的深度优先搜索，树的前序遍历等

#### 迭代算法
定义

	一种被重复调用有限次数的算法，每次调用都是一次迭代 ---> 循环
	通常用于数据集中递增移动

要点

	通常迭代的形式: for、while等
	把迭代看作是在集合中依次遍历每个元素
	通常用于容器的遍历

递归 VS. 迭代

	由于递归和迭代可以相互实现，两者之间的区别很难清晰地界定。
	通常递归的可读性更强，更易于实现，和维护
	迭代占用的内存更少，效率更高 （这就是为什么使用迭代的原因）
	函数式语言趋向于使用递归（如 Haskell 语言）
	命令式语言趋向于使用迭代（如 Ruby 语言）
	
	遍历数组的伪代码
		Recursion							 | Iteration
		-------------------------------------|------------------------------------
		recursive method (array, n)			 | iterative method (array)
			if array[n] is not nil		     |   for n from 0 to size of array		
				print array[n]				 |		print(array[n])
				recursive method(array, n+1) |
			else 						     |
				exit loop					 |

#### 贪婪算法
定义

	在执行某事件的过程中，只选择满足某一条件的信息(一般是最大值，最小值等)
	通常包含5个部分：
		候选集			从该集合中可得出解决方案
		选择函数		选取要加入解决方案中的最优候选项
		可行性函数		用于决策某一候选项是否有助于解决方案
		目标函数		为解决方案或部分解赋值
		解决方案函数	将指明完整的解决方案

要点

	用于找到预定问题的最优解
	通常用于只有少部分元素能满足预期结果的数据集合
	通常贪婪算法可帮助一个算法降低时间复杂度
		
#### 动态规划
定义

	动态规划过程：每次决策依赖于当前状态，又随即引起状态的转移。决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
	基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。
	在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
	与分治法最大的差别是：适合于用动态规划法求解的问题，分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
    状态保存：由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。
	
	划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
	确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
	确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
	寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

要点
	
	适用范围：
		最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
		无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
		有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。
