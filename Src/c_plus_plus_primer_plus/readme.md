#读书笔记
#### C++ primer Plus(6th edition) --- Stephen Prata

今天终于粗糙的把这本书读完了一遍(附录部分还没有读，看书有点不喜欢看附录)，这本书900多页，内容18章(800多页)+附录+习题答案，
没有想到这么快看完的，我是对着PDF电子版看的，预计是这学期看完，半年时间吧，甚至担心自己看不完，太厚了一点，结果仅仅用了2个月吧，
10月多开始看的吧，现在才12月4号，实际看书时间大概不足一个月吧，看来看书比想象中的容易很多。
	
看完这本书，对C++的认识完全不同了，再也不敢说自己熟悉C++了。想起以前，向别人介绍自己的时候，总是喜欢说，我熟悉C/C++语言，真是
羞愧啊，无知者无畏！！！还好没有说精通C++啊，对于C语言也许勉强说得上熟悉吧，想想也是很心虚的。

个人感觉比较喜欢C语言，我认为面向过程编程很自然，很符合思考的逻辑，写程序也就很自然的实现了，特别是实现那些数据结构中的算法的时
候，感觉C语言最适合了。一直感觉写C语言程序更加简单，所以很少使用C++的类什么的知识。最主要还是，对于
面向对象编程，一直感觉很抽象，也看了很多相关的一些零散的内容，感觉很简单，没有什么内容，就是封装了一下而已，没有怎么高级啊。
由于接触的很多语言都支持面向对象编程，所以看的相关书籍、教程自然会讲到面向对象，类的一些最基本的知识，看得多了，现在也慢慢了解了
一些类的特性和功能，虽然说不上理解，掌握的，应该能够清晰的表达了。但是这些和C++类知识比起来，还是远远不够的。

其实C++我也简单的学习了一些，但是以前看的书不多，没有完整的看过一本C++书籍，java的基础书籍，倒是还完整的看完了两本，以前还是
太幼稚了，以为语言差不多，了解语法就可以用了，以为会了cin/cout，就是会了C++，后来才知道需要知道类，创建类，也是很简单，没有什么
高深的知识，然后就自以为是的以为，自己会了C++，实在是可笑之极。

后来，我才慢慢的明白，我的状态只是使用C++，进行C语言式的编程而已，使用C++的简约性，不会像C语言那么严格的错误检查、类型什么要求，特别
是变量定义，必须在函数前部分定义很讨厌。实际上C++的功能还没有利用到10%吧，基本都是C语言的一些基础而已，很简单的几个C++基础知识而已。

	其实cin/cout已经包含了C++的50%以上的内容吧，只是我自己不知道而已，单纯的当做好用的输出，输入而已。
		0.命名空间的使用，using编译原理等，可惜根本不知道其原理，也没有想过为什么，只知道那么用了。
		1.首先cin/cout是对象，类的实例化
		2.成员函数的重载，都重载了很多的插入运算符、抽取运算符，因此才实现了智能输入和输出
		3.cin的类型转换，eofbit/failebit/badbit
		4.返回自身对象的引用，所以可以实现拼接 cin >> a >> b
		5.控制符的实现
		......
		内容多不胜数，都是高深的内容，只是我不知道而已！
	
C语言，使用C++编译，自然非常好用，因为很多要求放宽松了，编程格式简化了很多，所以感觉很舒服，然后以为就真的会了C/C++，真是
被骗得好惨，零星的接触了一些简单的C++知识吧，比如需要什么功能的代码，网上代码很多，看的有些东西，自然自己也会模仿一些，但是实际
根本没有理解，只是简单的copy吧。比如很强大的string、vector，虽然可以模仿的使用，但是它们是什么，实际上根本不知道，字符串、数组
仅仅是最表面的东西吧，实际它们根本就不是这么简单，只能说可以这么使用，它们的方法和实现，都是非常强大的，如果能够完全吃透这两个
类库，那才是熟悉C++了吧。

深刻的反思，C++很复杂，我了解的东西，真的只是皮毛，甚至还不足一根毛吧！
	
看完这本书，才知道类很强大，但是很复杂，根本不是C语言的struct比拟的东西，类的几个基本成员函数：无参构造函数(默认的默认构造函数)
一个参数的构造函数(此时也是转换函数，禁止隐式转换 explicit)、拷贝构造函数、移动构造函数、复制赋值运算符、移动赋值运算符，如果普通的
类确实很简单，都可以有默认的(default)，但是涉及到new/delete的时候，瞬间就复杂了，开辟空间，此时必须复制字符值，而不是复制指针值，因此
必须自己显示的定义这些函数。以前真的是完全不知道这些东西，只是知道有构造函数、析构函数而已吧，也知道拷贝构造函数，但是对于动态开辟
空间，以及这些函数的关系，完全无知了，还想着自己不用定义实现，默认编译器会自动实现，就够了，现在看来，真的是太过于幼稚了，看完这本书
才知道原来这里面的东西这么复杂，简直是晦涩难懂。

其实我很早就看完了林锐博士的那本书，专门写C语言的陷阱，但是就有完成string类的拷贝构造函数和赋值运算符的重载，当时只是把答案看了一下，然后
就以为自己知道了，笔试什么的应该能够背出来吧，现在想想，真是愚昧，完全没有想过要研究一下，了解为什么需要那样！那真是一本很深的书啊！

	类的强大功能: 继承，继承就有成员的覆盖、隐藏、虚函数、多态、dynamic_cast<>
	虚函数重载 override final, 默认参数不能重载
	
	类的高级功能：多重继承，虚基类，纯虚函数、抽象类、私有构造函数的类，用户不能实例化、=defualt、=delete等
	
	构造函数在初始化成员类别中初始化：const成员 引用成员 无默认构造函数的类成员，或者使用非默认构造函数的类成员，基类的构造函数等
	初始化顺序，和成员的定义顺序相关，和初始化列表中的顺序无关。
	
	友元函数、友元类、互为友元的类(必须注意定义、声明的顺序)
	
	函数重载、运算符重载 operator=() operator<<() operator()()
	
	模板(template<typename t, class u>)、模板类、模板函数、具体化(半具体化)、实例化
	
	容器类、迭代器、算法
	
	function模板、lamda表达式、初始化列表、智能指针、基于范围的for循环、foreach() generator()等
	
	类库：array vector list valarray string so on
	
	异常：try catch throw
	
	变参函数的实现：
		template<typename T, typename... Args>
		void show(const T& value, const Args&... args);
		
	自动类型推断：auto  decltype 返回类型后置
	类型简写：typedef  using 
	
C++功能很强大，复杂的内容非常多，只是我看完这本书，还记得的一些知识，不能说掌握、理解了，至少知道有这么个东西了，
和人聊天的时候，不会显得无知而又井底观天。现在才知道C++不是随便谁都能够说熟悉的，更加不用说精通了，学习C++的道路
**任重道远**！

	感悟：
		C++一定要先声明定义，然后才能使用，记住这个基本原则，就很容易理解互为友元类的顺序定义规则了，
		也能够理解了派生类中使用基类方法的时候，为什么使用类作用域解析运算符了。
		记住这个基本的原则，然后去理解那些看似非常复杂难懂的东西，应该会轻松不少！
		
		作用域解析运算符，解释的是变量、结构、类、对象等的作用域范围，只有在有效的作用域范围之中，才能正常使用，
		在作用域之外，相当于没有定义，自然不能使用。

**Date: 2015-12-04**


	

	
	