#The C++ Programming Language(Special Edition) -- Bjarne Stroustrup 裘宗燕译

刚刚看完C专家一书，收获有哪些，具体也说不上，以前知道的内容，自然看得很轻松，当做复习巩固一遍，有些新颖的内容，看得很晕乎，感觉太深了。我的看书
陋习，不喜欢看第二遍，所以直接开始看这本书了。

这本书比较厚，900多页，内容比较多，看得最吃力的一本书，很多内容很新，以前没有见过的说法，一天想看完20页，都感觉很吃力，我一般是上午坚持学习C/C++，
其他时间学习其他的东西，以C/C++为主，作为找工作、职业发展的重点，学习Java、PHP等作为其他兴趣，然后边做项目，现在都必须加班，下午还得再看1个小时左右，
否则很可能上午只能看几页，10页。其实上午我一般9点左右到实验室，11点左右吃饭，简单的内容，其他书好像很容易看20页-30页左右，这本书，内容很苦涩，看得很难理解，
好像有的翻译语句都不通顺，不知道我理解能力太差，还真的是读不通。希望我可以坚持看完，今年回家过年前，多看一点。**Date: 2016-01-05**

开始看书时间，应该是2015-12-27左右，就当做元旦开始的吧，期待我看完这书的那一天，然后看看共用了多少时间，并且来完成这篇读书笔记，写写学习总结和心得。


第11章，运算符重载

	静态对象缓冲区，很不错的技术

第13章，模板

	模板中的高级技术，从基类派生出模板类，或者模板类派生；全部(部分)专门化，抑制代码膨胀，实现共享；模板默认参数
	
	抽象类：运行时多态，编译时不知道对象的类型，具有类层次结构
	模板：编译时多态，不具有层次结构性关系，效率更高，容易实现inline。

第14章，异常处理

	异常处理中的技巧，
	保证资源申请和释放，
	将资源指针封装在类中，
	利用类的构造函数、析构函数，创建和释放，
	RALL “资源申请即初始化”技术。	RTTI（Run-Time Type Identification)
	
	auto_ptr 所有权语义(ownership semantics)	破坏性复制语义(distructive copy semantics)
	
第15章，类层次结构

	这章讲类层次结构，实在是感觉很复杂，逻辑很绕的。多重继承，虚基类的，运行时类型信息

	用户界面系统的开发，技巧实在是灵巧。界面与实现隔离，并隐藏实现细节
	dynamic_cast限制在多态类型上，虚函数表中，存放有一个指向类型信息的指针
	dynamic_cast在指针转换时，表示提问，失败返回0；在引用的转换时，表示断言，失败抛出bad_cast异常。
	dynamic_cast 在基类指针确实指向派生类对象的时候，就可以将此基类指针强制转换成该派生类指针，否则准换失败。
	
	任何时候，都不要尝试把将基类指针转换为派生类指针，未定义！ 
	15.5.1 反变：指向基类成员的指针可以安全的赋值给指向派生类的成员的指针	--> 允许指向派生类的指针给指向基类的指针赋值<-->多态
	
	虚析构函数	多态的运用
	
第16章，库组织和容器

	主要讲了标准库组织和容器，内容很多，技巧很强，很多都是看着好像明白，实际应该是完全不会的

	标准库的设计，容器的设计，技巧非常强，从灵活、方便，但效率不高的基类抽象派生到兼容灵活、方便、效率的统一界面的模板方式使用，
	一个模型比一个模型漂亮。
	
	16章的主体是讲解了vector模板，既帮助学习运用vector，又可以学习标准库、容器的开发。看本书之后，才知道自己对于vector的无知，平常使用很少，
	一般只会使用数组，C风格的影响，现在慢慢理解了模板，类型参数这类看似神奇的东西。
	
	vector里面的内容非常丰富，第一个让我开眼界的就是，类型当做类成员变量，第一次看见，神奇。使用技巧：typename C::value_type 
	typename可以告诉编译器，该成员属于类型，不是普通成员。
	
	再一次理解的迭代器，iterator，一直感觉很神奇的东西，其实也就是一个类，或者一个类型。使用不用管，直接 "vec.begin()+i"即可，
	*it ++it也是可行的(标准迭代器)，当做指针使用，实际使用不要用指针即可。算法的访问、操作，多是依靠迭代器的。sort()
	然后知道了，reverse_iterator 与iterator可能不同，但是可以转换：base()函数即可实现
	
	vector可以堆栈操作：push_back()	pop_back() back()
	表操作：insert()	erase()
	容量：size()	resize()（realloc()）	capacity()	
		reserve() 预留空间，既可以提高效率，还能保证内存位置不变，即可保证避免迭代器非法，产生未定义行为，高技巧！
		
	vector的理解更加深刻了一些，[] 和 at() 的区别，一个是高效率不安全的，一个是有越界检查安全的。
		
	vector<bool> 专门具体化，需要考虑二进制位模拟寻址操作
	
	vector是非常强大的数组，只要掌握，使用超级方便。直接当做普通序列，数组；直接模拟stack, 使用三个相关函数即可；直接模拟string vector<char>
	
	vector的灵活运用技巧，关键就是看 typename T, 可以放入任何类型。放入vector就是数组的数组(二维数组)，放入point，就是点对。link就是链表向量。
	放入基类的指针，即可实现多态，非同质。

第17章 标准容器，主要介绍了各种容器的实现，包括有序列，适配器，关联容器，拟容器，自定义容器等，不仅有详细的关于实现的理论、技巧讲解，还有具体的
源代码讲解，分析。

	标准容器：序列和关联容器	标准容器所有可能之处，具有逻辑互换性，都可以使用，只是效率，特定操作不同而已
	序列：vector、list、deque
	适配器：stack、queue、priority_queue	适配器是通过序列定义适当的界面实现的。
	关联容器：set、map、multiset、multimap	关联数组，主要特征是，可以使用关键码作为下标，访问映射值。	pair<K, V>键值对操作
	拟容器：数组、string、valarray、bitset	非标准容器，实现不同，使用有些区别。
	hash_map的实现,hash_**		用户实现自己添加自定义容器，封装统一界面接口。
	
	关键操作：
		表操作(insert、erase)，堆栈操作(push、pop、back)
		排序、归并、查找、粘接(splice)、unique。。。
		
	内部数组的封装，实现统一界面
	operator[]() 和find() 的不同，对于关联容器，[]会插入不存在的关键码，改变容器，不能const
	
实际编程，根据需要选择合适的容器，首先vector，不要使用数组了。C风格的字符串，一定要提供适当的比较准则，strcmp()等。
map是有序的，hash_map是无序的。hash_map查找效率更高。
		
第18章 算法和函数对象
	
	标准算法在名称空间std中，声明在<algorithm>里，标准函数对象在名称空间std里，声明在<functional>里。
	
	Iseq封装迭代器，将输入序列变成明显可见的，简单、安全。
	
	函数对象	拟函数对象	应用运算符	谓词
	标准库提供了很多函数对象、谓词
	
	函数对象基类：unary_function<T, C>	binary_function<T, K, C>
	
	约束器
	成员函数适配器
	函数指针适配器
	否定器
	
	排序序列：sort、二分查找、归并、划分、集合操作：includes()、set_difference()、set_symmetric_difference()
	
	堆：heap	<--> priority_queue
		push_heap()、pop_heap()、sort_heap()	
	
	最大、最小	max_element()	min_element()
	字典序：lexicographical_compare()
	
	排列 next_permutation()		prev_permutation()
	
	兼容性：
		C语言中：qsort()	bsearch()
		C++中：  sort()		search()
		
	std::mem_fun和std::mem_fun_ref所实现的是相同的功能
		mem_fun()用于处理容器对象指针
		mem_fun_ref()用于处理容器对象实体
		
总结：标准库提供了很多算法，通用性、完整性、鲁棒性非常好，多使用算法，少使用循环，少造轮子！
find()	for_each()	tranform()	search()	sort()	unique()	remove()	lower_bound()...

第19章 迭代器和分配器 
	
	迭代器是链接容器和算法的纽带，提供了一个数据访问的标准模型
	分配器被用于将容器的实现隔离在对存储访问的细节之外，提供了一种映射，将低级数据结构模型映射到高级对象模型。
	
	iterator
		分类：Out In For Binary Rand
		操作：++ *p(读、写) --  +  == !=  
	
	iterator_traits
	
	inserter /back_inserter	(避免容器的溢出)
	
	迭代器操作，尽量使用前缀++，后缀++会产生临时变量，影响效率
	
	allocator
		new/delete
		malloc/free
	
	未初始化内存分配：
		uninitialized_copy()
		uninitialized_fill()
		uninitialized_fill_n()
		get_temporary_buffer() // 只分配不构造		return_temporary_buffer() // 只释放不销毁  (成对使用)
		get_temporary_buffer属于低级机制，专门用于快速分配，优化使用的，不能代替new()，allocator::allocate()
		
		Obj a = new Obj()	/	Obj *b = new Obj	a将被初始化为0，b不会被初始化，垃圾值
		
	raw_storage_iterator	做的是初始化，而不是赋值
	
第20章 串

	这一章，完整讲解了basic_string类的接口实现，接口非常多，但是分类很清晰，明确，并讲解了实现所需技巧和注意事项。
	typedef basic_string<char> string	basic_string<>是一个模板类，类似于vector一样的容器，接口和vector相似，
	string是basic_string模板的一个实例化。
	basic_string模板类的接口非常多，包含各种常规的操作。
	
	C标准库中，关于C风格字符串的操作函数，字符操作函数等
	
	atoi() atol() atof()		strtol() strtod()	仅错误处理方式不同，其他一样。
	long atol(const cahr *p);		long strtol(const char *p, char **end, int b);
	atol(s) = strtol(s, 0, 10)
	
	at() operator[] 区别：at()更加安全，有返回越界检查，[]和迭代器都没有检查。[]速度更快，效率高
	
	C++编程，尽量多用string，少用c风格字符串(多使用容器，标准库算法，少些循环，数组等一样) 【安全、效率】
	
第21章 流

	<iosfwd> 流I/O类和模板声明，标准typedef等，部分I/O头文件
	ios_base <-- bisic_ios <--(virtual public) basic_ostream(basic_istream) <-- iostream
	
	输出：从各种类型，到字符序列的转换结果
	输入：从字符序列，获取各种类型格式的值
		tie() 流联结，cin.tie(&cout)	自动刷新 cout.flush()
		sentry类：通过一个类，采用构造函数和析构函数，提供公共的前缀和后缀代码
	格式化：输出布局的需求
		flags()		用标志位的方式控制流状态
		操控符
		
	流：文件(istream, ostream, file)
		ostream istream iostream 
		ofstream ifstream fstream
		ostringstream istringstream stringstream
		ostrstream istrstream
	缓冲区：提高I/O效率
		basic_streambuf有两个界面：公共界面，保护界面
		showmanyc() 慎用(低级函数，与实现密切相关)
	locale：文化差异
		imbue() global() locale类、facet类
		流回调：xalloc() iword() pword()
		typedef void (*event_callback)(event, ios_base &, int i);
		void register_callback(event_callback f, int i);
		在流状态改变时，就会调用注册的“事件”相关函数，通知用户
	C语言I/O：scanf() printf()
		printf(const char *format, ...)
		fprintf(FILE *, const char *format, ...)
		sprintf(char *, const char *format, ...)
	printf()不检查参数类型，不安全
	
第22章 数值

	数值限制：模板类numeric_limits<>(limits)  继承于C的宏 INT_MAX(climits, cfloat)
	valarray 构造函数，值在前，个数在后valarray(value, nums)
		slice_array：slice作为valarray的下标的结果，禁止构造和复制
		gslice_array：gslice作为valarray的下标的结果，禁止构造和复制
		mask_array：valarray<bool>屏蔽的效果，用valarray<bool>作为valarray的下标的结果
			bool b[] = { true, false, false, true, ture, ture };
			valarray<bool> mask(b, 6);
			valarray<double> val1 = { ... };
			valarray<double> val2 = val1[mask]; // mask.size() < val1.size()
		indirect_array :将一个valarray<size_t>用作valarray的下标的结果
			size_t i[] = { 3, 2, 1, 0 };	// 下标不能重复，否则indirect_array结果未定义
			valarray<size_t> index(i, 4);
			valarray<double> val1 = { ... };
			valarray<double> val2 = val1[index];	// index.size() < val1.size()
		四个类valarray，都是禁止构造和复制
		
	slice Slice_iter Cslice_iter
	
	封装表达式的求值，多元运算符的实现，辅助类(闭包对象包装)，函数指针
	性能的优化：避免类对象的临时变量、对象复制、循环中重复操作
	
	通用数值算法：
		accumulate: 向量元素求和的推广，累加序列所有元素的和，或者传入二元运算符函数对象，做对应操作
			template<class In, class T> T accumulate(In first, In last, T init);	// 默认 + 求和
			template<class In, class T, class BinOp> T accumulate(In first, In last, T init, BinOp op);
			
		inner_product: 内积，默认 +，* 向量点乘法
			template<...> T inner_product(In first, In last, In2 first2, T init);	// 向量点乘 
			template<...> T inner_product(In first, In last, In2 first2, T init, BinOp op, BinOp2 op2);	// 自定义操作 
			
		partial_sum: 输入序列a,b,c,d 返回序列：a,a+b,a+b+c,a+b+c+d.
		adjacent_difference: 输入序列a,b,c,d 返回序列：a,b-a,c-b,d-c.
		这两个操作的结果互逆。
		
		随机数 rand() srand()
		int((double(rand()) / RAND_MAX) * n) 要好于 rand() % n
		
第23章 开发和设计

	面向对象的设计：C++的数据抽象，面向对象程序设计功能
	开发过程：
		分析：定义需要解决问题的范围
		设计：建立系统的整体结构
		实现：写出代码，完成测试
		试验、测试、对设计和实现的分析、撰写文档、管理
	设计目标：灵活性、可扩展性、可移植性(发布满足用户需求的产品)
	组件(相关类的集合，类库)设计的步骤：
		1.发现类：将真实世界中的概念直接拿来作为类。先创建初始的类和关系，然后反复对它们做精化
		2.描述类操作：最小化设计，添加函数比删除函数更加简单。
			基础操作、探查操作、修改操作、转换操作、迭代器 (分类使得设计更加规范，简单，保持一致性)
		3.描述类间的依赖性：参数化(模板)、继承关系、使用关系
		4.描述界面：界面与实现无关。保护界面、公用界面
			类里的所有操作，应该支持同一个抽象层次
		5.类层次结构的重组：抽取类间的共性，生成公共基类；把一个类分裂成两个类
		6.模型的使用：为新的设计使用现存的系统作为模型，比白手起家强。(站在巨人的肩膀上)
	测试：尽可能早做，尽可能经常去做	
	不成熟的优化是一切罪恶之源：效率不能不关注，也不能过分关注。优化一定要基于性能实测，而非“直觉”。
	
	为特定项目的开发，选择适当的规范性水平：大项目必须有严格的规范标准，小项目尽可能的少标准束缚(没有银弹)
	
这一章内容很多，讲授了很多方法，技巧，偏理论，读起来很吃力，需要仔细琢磨，最好有实际项目的体验。但是软件开发的基本方法和
原则还是一样的，和《代码大全》里面讲的很多观点相同。软件工程本身就很复杂，项目规模、类型各式各样，没有适合于任何项目的标准
方法和准则。第一步，必须了解需求，需求分析越完善，精确，开发设计越简单，后期需要修改，完全重写的可能性更小。制定标准，对于
大型、中型项目必须有开发标准，维持项目的统一风格，否则一片混乱。中小型项目的标准不能太严格，否则成为累赘。软件开发是一个循环
迭代的过程，反复调整，修改而成的，不能希望一次成功。设计的基本单位是组件，不要以孤立的类，作为设计单位。调试、测试、优化都是
不可或缺的过程。

软件开发核心，就是管理复杂度。大的系统分化为小的系统，复杂东西简化为简单东西，建立原型，初步实现一个简单的系统，一步一步添加
功能，完善系统，复杂的东西，也就在不知不觉中实现了。尽可能早的测试，尽可能多的测试，越早发现问题，其修改代价越低。

软件开发的目标，发布用户满意的产品！
		
第24章 设计和编程

	忽视类：C语言等面向过程式的编程设计  (设计工作的基本点，放在类上而不是函数上)
	忽视继承：继承破坏了信息隐藏。保持开放的心态，谨慎使用继承，仔细虚函数，保护成员。
	忽视静态检查：动态类型检查的额外开销是3到10倍。强类型检查有利于系统的集成
	忽视程序设计：自动代码生成技术(特定应用领域才行)，程序设计本身就是为了实现某些自动化系统或者库，不可能取消。
	
	类层次结构：公用继承、私用继承	虚函数，保护数据成员(框架)
	信息封装隐藏：使用非虚函数，私有数据成员，避免保护成员和虚函数
	非成员函数，友元函数，名称空间成员
	
	编译器支持类的静态类型检查，类间、类内关系的分析是系统设计的中心
	继承关系，有助于类型检查；包含关系无此优点，但有利于类型间的相互转换(毕竟只是一个标记)
	
	派生类中间接使用的virtual函数，可以声明为private，需要直接调用的函数，应该是protected
	公用派生：界面继承，允许派生类向基类的隐式转换
	私用/保护派生：实现继承，不允许隐式转换，等价于包含关系，除了覆盖问题
	
	包含和继承：is-a  has-a关系
	成员和层次结构的权衡：成员关系(标签标识不同类型)在于运行时决策(switch)，继承提供了静态类型检查
	包含和层次结构的权衡：“它能有两个吗”的经验规则
	
	转换运算符：一个参数的构造函数(默认参数多个的)、X::operator Y()
	
	对象层次结构：类的成员是其他类对象的指针或引用，是类层次结构的补充。
	
	不变式(保持对象的良好状态)、断言：前条件，后条件
	C++封装是以类为单位的，通过指针，一个对象可以直接通过其成员函数访问其他对象(如：链表)
	嵌入内部和“非嵌入”：默认选择尽可能使类局部化，除非确实需要广泛使用
	
	类层次结构：所有的对象都能放入一个类层次结构时，且运行时需要加入新的对象类型，则使用虚基类
	模板：如果对象类型不能放入一个类层次结构，对运行时间有严格要求的，则使用模板
	模板、类层次结构，实际代码无区别，一个是编译时多态，一个是运行时多态，只有在运行时间、重新编译等存在差异。
	
	简单类型，可以使用普通对象成员，对于重要组件的界面类型，适合使用指针或引用成员，
	这样该类声明可以不依赖于其成员类的实现，只需要类名即可。
	
	肥大界面：所有操作的并集，尽量避免肥大的界面，性能牺牲大，错误或异常难以处理。
	
	设计原则：多采用数据抽象和面向对象程序设计的模式(C语言也可以支持面向对象的设计，使用struct和函数指针)
	代码要优雅、近似现实世界的概念，接近人的思维，可读性强，易于维护。
	
这一章主要从类的设计和实现的角度分析了系统设计方法，类的设计和实现技巧很多。使用类层次结构，还是包含关系，
数据成员使用普通对象成员，还是指针和引用对象等，都是需要权衡的。系统设计和实现一般分为界面和底层实现，界面应该保持
一致性，尽可能隐藏实现细节，仅提供需要提供的服务。类的设计原则，尽可能使用private，其次protected，再次public，
设计对象的不变式。避免肥大界面，运行时性能损耗大。

C++的封装是以类为单位的，不是对象；系统设计是以组件为单位的，不是类。

C++对象的内存模型：虚函数(用于实现多态机制)的实现，对象的第一个字段就是一个虚函数指针，指向虚函数表，虚表中的
字段都是指向类的虚函数的指针，这些字段都是编译器自动实现，并添加的。对象中，只有非静态数据成员，
共享的数据(静态数据、函数、静态函数、虚函数)都是属于类的，通过指针指向一个位置，间接访问的。

类层次结构中的单继承：虚函数指针字段前面，有一个type_info的指针字段，可以获取类名等类的信息。

第25章 类的作用

	具体类型：像一个内部类型，内部类型都是具体类型
		尽可能紧密地与特定概念或者实现策略相匹配
		inline处理，提高代码运行时间和空间效率
		对其他类的依赖尽可能小
		能够独立的理解和使用
	具体类型少用于派生的基类，多使用于类成员对象的包含关系(如内部类型 int)，再封装出需要的抽象界面
	类层次结构的缺点：
		效率低下：虚函数的调用花销更多；虚函数类，需要更多的空间花销(虚表指针)，虚函数不能是inline
		需要自由存储：派生类的大小可能不同，故需要在自由存储中分配他们，局部变量会减少
		使用不方便：利用虚函数的多态，必须使用指针或引用进行访问
		弱化了封装：虚函数可以覆盖，protected数据，派生类可以访问。
		
	抽象类型：表示公共概念的一组实现的公共界面
		一个界面，允许多种实现
		通过虚函数，提供合理的时间和空间效率
		使每个实现对其他类的依赖性最小
		能够独立的理解
	抽象类型提供通用性，牺牲速度；具体类型提供速度，牺牲通用性。
	
	结点类：被设计作为某个类层次结构中的一个不可缺少的部分的典型类，依赖于自己的基类的服务去提供服务，
		不仅提供了基类的界面的实现，而且还会加入自己的新函数，提供更多有用服务
	结点类具有构造函数，通常比较复杂的构造函数，抽象类通常不具有构造函数。
		实现和界面都依赖于它的基类
		提供了一个比它的基类更宽的界面
		基本上依靠它的虚函数
		可以被用做基类进一步派生新类
		
		可以创建对象
	具体结点类、抽象结点类
	
	动作类：函数对象、操控符、组合符类(推迟执行)
	
	界面类：为了某些局部需要，而简单的调整某些服务的表现形式，完成界面的调整。
	抽象基类、句柄类都属于界面类
	多重继承完成界面的合并(存在名称冲突，基类间的虚函数同名，辅助类处理)
		用于为非C++代码提供C++界面；用于将应用代码与库的细节隔离；提供带检查的或者受限的界面
	包装器：控制对其他类的访问或调整其界面的界面类也被称为包装器
	
	句柄类：句柄包含一个指向表示的指针，比单独的表示指针信息多一点点，句柄布局一般稳定，即使表示发生变化
		句柄为相应的表示提供了界面、访问控制、存储管理
		句柄：重载operator ->()运算符，取得表示的操作
	类对象大小固定，但是不同实现的派生类的大小可能不同；不使用指针或引用，即无法利用虚函数的优势
	使用句柄避免直接使用指针或引用。
	将一个对象分成两个部分：一个提供用户界面的句柄部分，另一个保存着对象状态的几乎所有信息的表示部分
	引用位于远程计算机上的对象时，常常需要使用代理型的句柄
	
	应用框架类：提供一些能够建立起某种公共框架的代码，将有关应用的专用代码作为块装进去
	应用框架的类具有肥大界面，很接近一个理想的完整应用，但其中什么都不会做。
	框架通常是一种结点类的层次结构
	
本章主要讲了类的7中分类，通过介绍7种类的定义，应用，优缺点等方面，阐释了类的作用，类的设计方法。每种类都有
适合的应用领域，也有相对应的优缺点，设计者需要做的，就是做好权衡和选择，然后进行正确的类设计。

具体类，适合于简单独立的概念，最佳效率且及其关键的概念，不适合类派生；抽象类适合定义界面，实现不同的底层实现；
结点类适合共享许多实现细节的近似概念，用于扩充一个实现；界面类适合调整一个类提供的服务，而不修改这个类，易用
界面类增加范围检查；句柄类可避免直接使用指针或引用，可管理共享表示(引用计数器)；框架类适合能够预定义控制结构
的应用领域(有成熟理论、应用的领域)。

###### Date
开始时间：2016-01-01

结束时间：2016-05-09

#### 阅读感想
真的不容易，坚持看完了这本书。全书900多页，主体章节分4大部分，25章，包含了700多页，附录部分200多页。今天终于坚持
看完了前面的主体章节，附录部分还没有看书，先写点东西，激励一下自己。这本书，我看着非常吃力，感觉很多内容生涩难懂，
设计很多巧妙而复杂的技术，对于C++语言的特性和细节，讲解非常细致入微。对于面向对象设计，类设计，模板，库设计等方面，
都有深入的讲解和样例代码展示。非常适合作为深入学习C++语言的教程，本来以为自己的C++语言掌握很好了，看这本书才知道，
自己学习的都是一些皮毛，语法的基础，重要的特性，语法技巧，不要说掌握，很多以前都没有见过，听过。

看这本书真的很痛苦，看书的速度真是蜗牛一样，无论多么想加油，想看快点，一个上午3个小时，常常只能够看10页左右，这是
好的情况，也经常一个上午只看了2页，3页，吃完饭还得加班2小时或1小时，继续看几页。有两个方面的原因，一是我上午看书
确实效率不高，能够学习已经很不错的了；二是这本书真的不容易看，很多话不好理解，反复看了5遍，10遍可能还是不理解，读不
通的，理解能力不够，希望有一天看看原版的，可惜英语太没有自信了。

看完这本书的收获，好像出不出来什么收获，很迷惑的感觉。上次面试的时候，刚好面试官提高了iterator，可惜那个时候，还没有
看完，第一次面试也有点慌，所以结果很糟糕啊，看了这书上说的，感觉瞬间就掌握了iterator。
迭代器分5类：Output Iterator	Input Iterator	Forward Iterator	Bidirectional Iterator	RandomAccessIterator。
不同的迭代器支持不同的操作，只有随机迭代器支持operator +()操作，其他的支持operator ++()操作，迭代器前缀++效率更高。

一些零零散散的技巧，可能学会了一些，可能也没有学会吧，这本书真的需要反复多遍的看，毕竟很多东西都没有看懂，其他书需要
反复看，是因为书看了不久，就会被忘记了。

	