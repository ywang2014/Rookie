#Effective C++(3rd Edition) -- Scott Meyers 侯捷译

这本书是我在远景能源实习的时候，大牛推荐的一本C++经典书籍，在很多博客，论坛上也常看见有说《(More)Effective C++》很经典，Scott Meyers系列的书籍都是经典书籍，下载了PDF版本的，但是不知道为什么就是没有开始看这些书，可能对于编程人员来说，计算机科学中的经典书籍实在是太多了，你看一本书，书中引用的，作者推荐的书籍也是数不数胜数，本人也曾踏踏实实的看了一些计算机经典书籍，从我的**[github](https://ywang2014.github.io)**上可以看到相关的记录，所以对于书籍之多的感觉，实在是理解深刻。这本书也是在实习期间看完的，实习期间，每天坚持看看一点点，有时间就多看看，没有时间，可能几天都忘记了看，所以前前后后拖拉了4个月。四个月的时间，看这么薄的一本书，确实有些汗颜，但是在实习期间，坚持看完了一本书，也算是一种收获。

书真的是看不完的，即使只是看经典书籍，也是难以看完的，当然了所谓的“经典”，也是有很多分歧的，很模糊。计算机科学发展这么多年了，高级编程语言发明的年数也是不短了(C语言创始于1972年)，相关的著作如漫天的繁星，公众比较认可的经典书籍也如过江之鲤，想看完，在校期间那么几年应该是不靠谱的。因此，看书很重要，选择看什么书同样很重 --- 好钢用在刀刃上！

Effective C++这本书籍，对于C++程序员的编程实践和指导，特别是编写安全、鲁棒性高、符合C++语言规范的程序方面，意义巨大，一条一条的准则，都指导着程序员，编写出更好的C++程序，如果对于全书55个准则，都理解透彻，能够在编程实践中，遵守这些规则而不越界，那么你的程序不仅仅会更加高效，而且bug率将会极大地降低。当你的同时还在内核中，苦苦追bug，查看栈的时候，你可以怡然自得的和你的coffee，这就是这本书的力量！

本人应该属于一个入门级的C++程序员吧，毕竟看过几本C++语言的书籍，基础语法了解一些，理解可能不深刻，没有实际产品的项目，对于软件开发，设计模式，鲁棒性什么的更是没有什么概念和理解。写过最大的C++程序，就是一个五子棋，其中电脑还是很傻很傻的那种。看了这本书，才知道c++的水是那么的深，基础语法之外的东西，还有那么多，也明白了，为什么大牛都非常谦虚地说：“我没有精通C++，还不够格”。但是这本书对于我对C++的理解和使用方式，确实给出了很多指导和建议，使得我对于c++的理解，更加深刻了。

Effective C++不仅对有实践开发经验的工作者帮助具体，对于刚入门的程序员也是很有帮助的，看这本书，可以使初学者少走很多弯路，在实际学习中，少遇到奇奇怪怪的问题，写出质量更高的程序代码。同时也能提高初学者对于C++语言的理解，对很多C++语言特性的实际应用有所了解，甚至是掌握其中的编程方法。我所说的初学者，指的是C++入门后的初学者，即知道C++基本语法，编写程序基本规则的初学者，不是对于C++只知道这个语言名字，其他一无所知的初学者，看这本书之前，你必须至少看完了一本C++入门书籍。

当然了，看完Effective C++，要想说熟练掌握C++，好像还是不够格的，不信的朋友，看完这本书就知道了，C++里面的东西真的是太多太多了。想通过一两本书就能掌握C++里面的东西，远远不够的。这本书讲的东西不少，但是没有涉及到的东西，也是很多，这本书很多内容讲的还是不够详细和深入，知识的讲解，显然不是作者的重点，作者专注的还是C++语言编程的规范，指导编程实践的忠告！

Effective C++全书包括55个改善程序与设计的指导建议，划分为9章，269页。这本书比较薄，正如同其介绍中说的，这是一本浓缩了C++专家经验的书籍。---**了解C++如何行为，为什么有那样行为，如何运用其行为**

#### 1.让自己习惯C++
1.视C++为一个语言联邦：面向过程编程(C语言)，面向对象编程(class)，泛型编程(template)，函数式编程(function)，STL(容器，算法，迭代器)

2.尽量不使用#define：宏定义继承自C语言，问题很多：无类型检查、无作用域约束等，尽量使用inline+const实现宏定义，除非有些特殊情况，不得不使用#define。编译器比预处理器强大！

3.尽可能使用const：某些变量，成员函数是const的时候，尽可能说出来，获得编译器帮助，提高程序鲁棒性。

	const int *p;			// *p is const 
	int* const p;  			// p is const
	const int* const p;		// *p and p both are const 

4.确定对象使用前已被初始化：C++一般不保证初始化对象，程序员在使用对象前应该手动初始化，特别对于指针，使用前一定要初始化，否则出现未定义行为。类的构造函数，使用成员初始化列表。

#### 2.构造、析构、赋值运算
5.C++默认生成的函数：无参构造函数、析构函数、拷贝赋值函数、拷贝构造函数(public and inline)

6.显示声明自定义函数，拒绝默认生成的：编译器会为类自动生成构造析构函数，如果需要自定某函数，必须显示定义出来，特别对于需要动态分配内存的类，必须提供自定义的构造函数、拷贝构造、拷贝赋值、析构函数，否则编译器提供的默认生成的函数，都不能进行深度复制，行为不是你希望的行为。

7.virtual析构函数：基类的析构函数，一定要声明为虚函数，否则基类析构函数无法正常调用，造成内存泄露！

	析构函数可以是虚函数，不能重载
	构造函数不能是虚函数，可以重载

8.别让异常逃离析构函数：

9.绝不在构造和析构过程中调用虚函数：

10.令operator=函数返回引用：

11.在operator=函数中处理“自赋值”：

12.深复制：对于分配内存的对象，必须使用深度复制，浅复制，只是复制指针的地址，实际内容没有完成复制。

#### 3.资源管理
13.以对象管理资源：对象管理资源，借助其析构函数，自动析构，防止资源泄露。

14.资源管理类中小心copy行为：

15.在资源管理类中提供对原始资源的访问：

16.成对使用new和delete：new和delete必须成对使用，否则容易造成资源泄露，手动管理内存，必须实现自己分配内存，用完之后，保证自己释放内存。数组分配：new[]和delete[]也必须是成对使用。

17.以独立语句将newed对象置于智能指针：智能指针，可以自动完成资源的释放，避免内存泄露，减少程序员的工作难度。


#### 4.设计与声明
18.让接口容易被正确使用，不易被误用：接口习惯尽量满足约定俗成的习惯，绝对不要标新立异，减少用户的记忆量。比如：operator+即完成通常意义的加法功能，千万不要实现减法或者其他功能，容易造成误解。尽可能保证，看见api名字，即知道函数的功能，而不需要一个个的研究文档，设置看函数源代中的具体实现。

19.设计类犹如设计内置内型一样：类设计的接口越完善，越接近内置类型，用户使用越简单越方便。

20.以常引用传参替代值传参：对象使用常引用传参，可以提高效率，const保证参数不被修改，鲁棒性。

	内置类型，直接传值更高效。

21.必须返回值时，不能返回引用：函数不能返回局部变量的引用或指针。

22.成员变量声明为private：成员变量不应该暴露给用户，统一提供public接口操作，封装

23.尽量使用非成员，非友元函数替换成员函数：如果一个函数不访问类的非public接口，请使用非成员函数，封装性

24.若所有参数需要类型转换，请使用非成员函数：自动的隐式类型转换，不能使用成员函数，成员函数的第一个参数，必须是对象本身，无法进行类型转换。

25.考虑写一个不抛异常的swap函数：pointer to implementation, 对于指针成员变量的时候，自定义swap，提高效率。

#### 5.实现 
26.尽可能延后变量定义式的出现时间：变量尽可能在使用的时候，再定义，减少其跨度和生存期，提高程序鲁棒性。

27.尽量少做转型动作：类型转换，主要安全性

	dynamic_cast<>		// 安全的类型转换，派生类转向基类
	static_case<>		// 不安全的类型转换，基类转向派生类
	const_cast<>		// const转换
	reinterpret_cast<>	// 强制类型转换

28.避免返回handles指向对象内部成分：封装性

29.写异常安全的代码：抛出异常后，对于分配的资源，一定要保证释放，避免资源泄露

30.inline：提高效率，减少函数调用

	编译器代码膨胀！

31.将文件的编译依存关系降至最低：声明和实现分开 .h  .cpp

#### 6.继承与面向对象设计
32.public继续是is-a关系：公有继承，说明派生类属于基类的一个特例，也是基类的一种

33.避免掩盖继承而来的名称：不声明和基类一样的函数(函数签名都一样)

34.区分接口继承和实现继承：继承基类的接口(抽象类)，继承基类的实现(STL容器中的适配器)。

35.考虑虚函数以外的其他选择：虚函数运行时多态，运行期开销大，使用其他方式替换，编译器多态

36.绝不重写继承而来的非虚函数：非虚函数不应该重新声明，会隐藏基类的实现。

37.绝不重新定义继承而来的缺省参数：缺省参数无法重写，重写使得函数行为非你预期的

	缺省参数是静态绑定的
	虚函数是动态绑定的

38.复合：has-a关系或根据什么实现：包含关系是has-a，或者私有继承

39.谨慎使用private继承：编译器不会将派生类对象转换为基类对象，implemented-in-terms-of，继承实现，不继承接口

	在软件设计层面没有意义，意义在于软件实现层面，借助已有的实现，完成新功能的实现。

40.谨慎使用多重继承：虚基类，菱形继承！

#### 7.模板与泛型编程
41.了解隐式接口和编译器多态：模板就是实现编译器多态

42.了解typename双重含义：模板声明中，和class完全一样，类声明使用class。内置类型使用typename
	
	如果解析器在模板中遇到这个嵌套从属名称，它便假设这个名称不是一个类型，此时必须显示指定是内型，使用typename

43.学习处理模板化基类内的名称

44.将与参数无关的代码抽离模板

45.运用成员函数模板接受所有兼容类型

46，需要类型转换时，为模板定义非成员函数

47.traits 类表现类型信息

48.认识template元编程

#### 8.定制new和delete
49.new-handler

50.何时需要自定义new和delete：监控内存时，log记录时，提高效率时

51.自定义new和delete的规范：定制new，提高效率

52.placement new和placement delete：最特殊的是包含一个指针作为参数的new，即在某块内存区域中，分配内存。

#### 9.杂项讨论
53.不要忽视编译器警告：任何警告信息，都不要放过，所有程序最低要求，0错误0警告 --- 千里之堤毁于蚁穴！

54.熟悉TR1程序库：Technical Report 1，包含14个组件，影响着C++标准

55.熟悉Boost：Boost是一个社区，一个网站，一个C++程序库。为C++标准库，挑选优秀的程序库

	
看完这本书，再写这边总结的时候，很多条款已经记忆模糊了，写不出那些建议，所表述的内容。这本书属于编程指导手册，看完，确实不能束之高阁，应该时时翻阅，反思自己的编程行为，哪些是错误的，应该避免，哪些还可以做得更加高效，有更好的实现，时刻反思，才能有更好的进步，否则总是原地踏步！

期待第二次打开此书！

**Data: 2016-10-03**